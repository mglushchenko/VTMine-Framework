







//======[1) main.cpp]=========================================================================================================================

reportException()
{
    // существ.
}

int startup(int argc, char *argv[]);

main(....)
{
    vtmine::AppStarter app;
    return app.start(argc, argv);    
}





//======[2) appstarter]=========================================================================================================================

class AppStarter {
    
    AppStarter()
        :  _frmw(nullptr)
    {
    }
    
      
    // запуск с обратчиком исключений последнего уровня
    int run(int argc, char *argv[])
    {
        int res = -1;

        // main app exception handler
        try {    
            res = startup(argc, argv);
        }
        catch (const std::exception& e)
        {
            reportException(e.what(), "Last STD Exception Handler"/*, logger*/);
        }
        catch (...)
        {
            reportException(UNKNOWN_EXCEPTION, "Last Exception Handler"/*, nullptr*/);
        }

        return res;
    }
    
    

    
    // основная логика
    int main(int argc, char *argv[])
    {
        shared_ptr<vtmine::FrameworkDefImpl> frmw(makeFramework(argc, argv));
    }
    
    
protected:
    
    
    void makeDefFramework(int argc, char* argv[])   // параметры создания фреймворка — пока не опрд.
    {
        if(!_frmw)
            reportException("Critical error: framework has been already created");
        
        // преобр. параметр если надо
        FrameworkDefImpl* _frm = new FrameworkDefImpl(.....);
        
        // доконфигурирование фреймворка в зависимости от параметров командной строки
        // много вопросов относительно доконфигурировани параметров
        
        // TODO: извлечь из параметров ком. строки последовательность -c _конф_файл_.json, который интерп. как основной ис
        _cmdlParams.parse(argc, argv);
        
        if(_cmdlParams.getConfigFileName().empty())
            reportException("Critical error: framework has been already created");

        
    }
    
    void reportException(const char* what, const char* capt)
    {
        // TODO: по дефолту выводит сообщ в std::cerr
        std::cerr << capt << " says: " << what;
        
        // потом здесь можно будет навернуть логику, которая переназначит вывод в другой объект
    }
    
    

protected:
    FrameworkDefImpl* _frm;
    CmdLineParams _cmdlParams;
    
};

    




//======[appendix]=========================================================================================================================

Параметры ком. строки
- https://code-live.ru/post/cpp-command-line-arguments/
- https://ravesli.com/urok-110-argumenty-komandnoj-stroki/
- https://habr.com/ru/post/150950/

Общие соображения:
1) используем в основном чтобы сконфигурировать основной процесс запуска приложения, поиска плагинов и вспомогательных файлов и конфигураций. Более тонкая и таргетированная (т.е. по конкретным плагинам/узлам/компонентам и т.д.) настройка осуществляется с помощью конфигурационных файлов, которые явно или косвенно могут быть получены приложением из известного источника.
2) коороткие аргументы (-a -s -d и т.д.) резервируем для самых важных и, потенциально, часто используемых команд. Например, -c _конфиг_файл_ ← передать основную конфигурацию программы в виде конфигурационного файла .json в программу. -h — справка.
Все остальные параметры, коих может быть в итоге сотни, передаются "длинным" образом через --help — тоже справка, только несокращенный синоним. 



//======[TODO]=========================================================================================================================

1) завести в репе папку /docs/ для документов.
2)  /docs/spec/ — папка для спецификаций
    /docs/spec/index.md (README.md — см. требования гитхаба) — главный вход со ссылками
    /docs/spec/cmdparam.md — описание параметров командной строки.
3) Поработать с кодов в соотв.  обсуждением.    
4) Потенц. вопросы с командной строкой: параметры используются НЕ только на этапе запуска фреймворка, но и потенциально далее передаются в плагины/компоненты и т.д. — нужно параметры командной строки тем или иным образом сохранить во фреймфорке — возможно в более удобном виде — вектор строк (std::string?) — 
5) См. класс AppParamsParser (app_params_parser.h/cpp), сделать такой же (самую-самую первую версию) для разбора параметров нашего приложения.
Лучше назвать его CmdLineParams.
6) AppStarter все же возвражаем. 


